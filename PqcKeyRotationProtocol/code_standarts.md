# Стандарты кодирования

## Общие принципы

* Современный C# (целевой `net8.0`/`net7.0`, C# 11/12 фичи по возможности).
* Никаких докстрингов, XML-комментариев и inline-комментариев в коде — только чистая логика.
* Имя классов/файлов отражает алгоритм/назначение (например `CrystalsKyberWrapper`, `PqcEncryptionWrapper`).
* Не создавать «utils» с общими функциями под этим именем (не называй класс `Utils`).

## Пространства имён и файлы

* Использовать file-scoped namespace: `namespace PqcKeyRotationProtocol.Crypto;` (НЕ `namespace { ... }`).
* Если интерфейс имеет **только одну** реализацию — интерфейс и реализация должны быть в **одном файле**.

## Интерфейсы и статичность

* **Не использовать публичные static методы**. Вся функциональность — через интерфейсы и инстанс-классы (DI-friendly).
* Интерфейсы проектировать минимальными и явными (например `IPqcEncryptionWrapper`).

## Конструкторы и инициализация

* Использовать компактные, современно выглядящие конструкторы; если можно — `class A(B b, C c) { }`-стиль (primary constructor pattern / компактная инициализация).
* Инициализация зависимостей через конструктор (внедрение зависимостей).

## Имена полей и переменных

* Приватные поля: `m_`-префикс, `readonly` если возможно, например:

  ```csharp
  private readonly KyberParameters m_parameters;
  private readonly SecureRandom m_rng;
  ```
* Публичные/внутренние члены именовать по PascalCase.

## Типы возврата и var

* **Где можно — используй `var`.** (т.е. `var x = ...;` при очевидном типе)
* Где требуется — используй явные типы (например в публичных сигнатурах, возвращаемых значениях интерфейсов).
* По возможности возвращать `IEnumerable<T>` или `IReadOnlyList<T>` вместо `List<T>`.

## LINQ и итераторы

* Использовать LINQ в «SQL style» (query syntax) там, где это повышает читабельность.
* Использовать `yield return`/`yield break` там, где пригодно (ленивая генерация последовательностей).

## Управление потоком и стиль if/тернарники

* Никакого компактного one-liner `if (cond) Do();` — ВСЕГДА скобки:

  ```csharp
  if (cond)
  {
      Do();
  }
  ```
* Тernary (`?:`) допустим **если оправдано** (не злоупотреблять), inline-if (однострочные if без фигурных скобок) — запрещён.
* Индексы (например `merged[lastIndex]`) — разрешены, `^1` (index from end) можно, но явный индекс часто предпочтительней по стилю.

## Data-types / Records

* Для простых контейнеров — `record` / `record struct` (immutable когда возможно), например:

  ```csharp
  public readonly record struct PqcKeyPair(byte[] PublicKey, byte[] PrivateKey);
  ```
* Для DTO/сообщений — использовать простые record/immutable структуры.

## Ошибки и валидации

* Явно проверять `null` и входные параметры, бросать исключения при некорректных входных данных.
* Использовать `ArgumentNullException`/`ArgumentException` по необходимости.

## Крипто-API стиль

* Предоставлять **высокоуровневые фасады** над криптографией (например `PqcEncryptionWrapper` / `CrystalsKyberWrapper`) с простым API:

  ```csharp
  var wrapper = new CrystalsKyberWrapper();
  var keys = wrapper.GenerateKeyPair();
  var enc = wrapper.Encapsulate(peerPub);
  var ss = wrapper.Decapsulate(priv, enc.CipherText);
  ```
* Под капотом могут быть низкоуровневые классы BouncyCastle, но наружный API — простой и чистый.

## Паттерны безопасности / практики

* Хранить приватные ключи локально в файлах/хранилище, сохранять в защищённом месте (по заданию — можно упрощать для дис-версии).
* При работе с секретами — избегать логирования значений секретов (для демо можно выводить hex в debug, но не в финале).
* При сравнении секретов — использовать сравнение в постоянном времени (`ConstantTimeEquals`).

## IO / WireGuard интеграция

* Изменение PSK делать атомарно: записать во временный файл и вызвать `wg set peer ... preshared-key /tmp/...` или atomically `mv` конфиг.
* Не хардкодить адреса — делать автоматический расчёт AllowedIPs (класс-калькулятор) и динамически модифицировать конфиг.

## Код-оформление

* Всегда фигурные скобки у блоков `if`, `for`, `while` и т. п.
* Минимум вложенности и чистые методы — функции по одной ответственности.
* Никаких комментариев/докстрингов в исходниках (код должен быть самодокументируемым).

## Тестируемость и отделение слоёв

* Код обязан быть тестируем — интерфейсы для частей (KEM, Signatures, WireGuard-adapter).
* Mock-backendы допустимы для демо/диссертационной версии (например `MockKemBackend`) — но API фасада тот же, что и для реального бэкенда.

## Файловая организация

* Каждый класс/интерфейс — в отдельном файле, за исключением случая «интерфейс + одна реализация» — тогда в одном файле.
* Имена файлов соответствуют именам классов.

## Логирование/ошибки

* Логирование минимально (для диссертации допустимо), избегать утечки секретов.
* Обрабатывать ошибки и приводить читаемые сообщения (без утечек секретов).